<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drift City: Night</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; outline: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Drift Score Panel - Centralt och stort */
        #drift-panel {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%) scale(0.8);
            text-align: center; opacity: 0; transition: opacity 0.2s, transform 0.1s;
            pointer-events: none;
        }
        #drift-panel.active { opacity: 1; transform: translateX(-50%) scale(1.0); }
        .drift-score { font-size: 3rem; font-weight: 900; color: #facc15; text-shadow: 0 0 20px rgba(250, 204, 21, 0.5); font-style: italic; }
        .drift-multi { font-size: 1.5rem; color: #fff; font-weight: bold; margin-top: -10px; }
        .drift-label { font-size: 0.8rem; letter-spacing: 4px; color: rgba(255,255,255,0.7); text-transform: uppercase; }

        /* Phone Interface */
        .phone {
            position: absolute; bottom: 20px; right: 20px; width: 300px; height: 500px;
            background: #111; border-radius: 30px; border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            overflow: hidden; pointer-events: auto;
            display: flex; flex-direction: column;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 50;
        }
        .phone.hidden-phone { transform: translateY(120%); }
        
        .screen { flex: 1; background: linear-gradient(180deg, #1e1b4b, #000); padding: 15px; overflow-y: auto; color: white; }
        .notch { height: 25px; background: #000; width: 50%; margin: 0 auto; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; }
        
        /* HUD */
        .hud-stats { position: absolute; top: 20px; left: 20px; color: #fff; text-shadow: 0 0 5px #000; pointer-events: none; }
        .speedometer { position: absolute; bottom: 20px; left: 20px; font-size: 2rem; color: #00ffcc; font-weight: bold; font-style: italic; pointer-events: none; }

        /* Buttons */
        .app-btn {
            background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.1)); 
            border-left: 4px solid #facc15;
            border-radius: 4px; padding: 15px; margin-bottom: 10px;
            cursor: pointer; display: flex; align-items: center; gap: 10px; transition: background 0.2s;
        }
        .app-btn:hover { background: rgba(255,255,255,0.2); }
        
        /* Mobile Controls */
        .touch-controls {
            display: none;
            position: absolute; bottom: 20px; width: 100%; height: 150px; pointer-events: none;
            z-index: 40;
        }
        @media (max-width: 768px) {
            .touch-controls { display: flex; justify-content: space-between; padding: 0 20px; }
            .phone { width: 80%; right: 10%; bottom: 10%; height: 70%; }
            #drift-panel { top: 20%; }
        }
        .t-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; backdrop-filter: blur(5px); border: 2px solid rgba(255,255,255,0.5); display: grid; place-items: center; font-size: 20px; color: white; user-select: none; }
        
        .notification {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border-bottom: 2px solid #facc15;
            color: white; padding: 10px 20px; border-radius: 2px;
            opacity: 0; transition: opacity 0.5s; font-weight: bold;
            pointer-events: none; z-index: 30; font-style: italic;
        }

        #reset-btn {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255, 0, 0, 0.5); color: white;
            padding: 5px 10px; border-radius: 5px; cursor: pointer;
            font-size: 12px; pointer-events: auto;
            border: 1px solid rgba(255,0,0,0.8);
        }
    </style>
</head>
<body>

<!-- 3D Canvas Container -->
<div id="canvas-container"></div>

<!-- UI Layer -->
<div id="ui-layer">
    <div id="reset-btn" onclick="respawnPlayer()">RESPAWN (R)</div>

    <!-- DRIFT PANEL -->
    <div id="drift-panel">
        <div class="drift-label">DRIFT COMBO</div>
        <div class="drift-score" id="drift-score-ui">0</div>
        <div class="drift-multi">x<span id="drift-multi-ui">1.0</span></div>
    </div>

    <!-- HUD -->
    <div class="hud-stats font-mono">
        <div class="text-3xl font-black italic text-yellow-400">$<span id="money-display">0</span></div>
        <div class="text-xs text-gray-400 mt-1 uppercase tracking-widest">Total Score</div>
    </div>

    <div class="speedometer"><span id="speed-display">0</span> KM/H</div>
    
    <!-- Notification Toast -->
    <div id="notification" class="notification">Välkommen till Drift City</div>

    <!-- Phone Menu -->
    <div id="phone" class="phone">
        <div class="notch"></div>
        <div class="screen">
            <div class="flex justify-between items-center mb-6 border-b border-gray-800 pb-2">
                <div class="text-gray-400 text-xs font-bold">DRIFT OS</div>
                <div class="text-yellow-400 text-xs font-bold">$<span id="phone-money">0</span></div>
            </div>
            
            <!-- Home Screen -->
            <div id="screen-home">
                <div class="text-xs text-gray-500 mb-2 uppercase tracking-wide">Garage</div>
                
                <div id="car-list"></div>
                
                <div class="mt-4 p-3 bg-gray-900 rounded text-center text-xs text-gray-500">
                    Drifta för att tjäna poäng.<br>Köp bättre bilar för att drifta bredare.
                </div>
            </div>
        </div>
        <div class="h-1 bg-white opacity-20 w-1/3 mx-auto mt-2 rounded-full mb-2 cursor-pointer" onclick="app.togglePhone()"></div>
    </div>

    <!-- Mobile Controls -->
    <div class="touch-controls">
        <div class="flex gap-4 items-end">
            <div class="t-btn" id="btn-left">◀</div>
            <div class="t-btn" id="btn-right">▶</div>
        </div>
        <div class="flex gap-4 items-end">
            <div class="t-btn bg-red-900/50" id="btn-brake">S</div>
            <div class="t-btn bg-green-900/50" id="btn-gas">W</div>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// --- GAME CONFIG & STATE ---
const Game = {
    money: 0,
    currentCar: 'starter',
    carsOwned: ['starter'],
    carHealth: 100,
    
    // Drift State
    isDrifting: false,
    driftPoints: 0,
    driftMultiplier: 1.0,
    driftComboTimer: 0
};

// Driftbilar: Justerade för lägre hastighet och bättre kontroll
const Cars = {
    'starter': { name: "Drift Missile (S13)", speed: 140, accel: 0.22, grip: 0.92, cost: 0, color: 0xcccccc },
    'silvia': { name: "Silvia Spec-R", speed: 170, accel: 0.28, grip: 0.90, cost: 5000, color: 0x3b82f6 },
    'rx7': { name: "Rotary Legend", speed: 200, accel: 0.35, grip: 0.88, cost: 15000, color: 0xeab308 },
    'supra': { name: "2JZ Beast", speed: 240, accel: 0.42, grip: 0.89, cost: 40000, color: 0xff4444 },
    'hoonigan': { name: "Drift King V8", speed: 290, accel: 0.55, grip: 0.85, cost: 100000, color: 0x111111 }
};

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.003); // Mer dimma för nattkänsla

// Stars
const starsGeo = new THREE.BufferGeometry();
const starsCount = 2000;
const posArray = new Float32Array(starsCount * 3);
for(let i=0; i<starsCount*3; i++) {
    posArray[i] = (Math.random() - 0.5) * 3000;
}
starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const starsMat = new THREE.PointsMaterial({size: 2, color: 0xffffff});
scene.add(new THREE.Points(starsGeo, starsMat));

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Lights
const ambientLight = new THREE.AmbientLight(0x222244, 1.5);
scene.add(ambientLight);

// Neon City Lights
const dirLight = new THREE.DirectionalLight(0xaaccff, 0.5);
dirLight.position.set(50, 100, 50);
dirLight.castShadow = true;
scene.add(dirLight);

// --- MAP GENERATION ---
const cityGroup = new THREE.Group();
const buildings = [];
const roadWidth = 24; // Bredare vägar för drifting
const blockSize = 90;
const citySize = 8; 

function createCity() {
    // Asphalt
    const planeGeo = new THREE.PlaneGeometry(2000, 2000);
    const planeMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 20 });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -0.1;
    scene.add(plane);

    // Neon colors for windows
    const neonColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0055];

    for(let x = -citySize; x <= citySize; x++) {
        for(let z = -citySize; z <= citySize; z++) {
            if(x === 0 && z === 0) continue; // Start area empty

            // Sidewalks
            const sw = new THREE.Mesh(
                new THREE.BoxGeometry(blockSize - roadWidth, 0.2, blockSize - roadWidth),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            sw.position.set(x * blockSize, 0, z * blockSize);
            sw.receiveShadow = true;
            cityGroup.add(sw);

            // Buildings
            if(Math.random() > 0.1) { // Fler byggnader
                const height = Math.random() * 60 + 20;
                const width = blockSize - roadWidth - 4;
                
                // Procedural Neon Building
                const bMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 });
                const building = new THREE.Mesh(new THREE.BoxGeometry(width, height, width), bMat);
                building.position.set(x * blockSize, height / 2, z * blockSize);
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Add Neon Strip
                const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                const neonGeo = new THREE.BoxGeometry(width + 0.2, 0.5, width + 0.2);
                const neonMat = new THREE.MeshBasicMaterial({ color: neonColor }); // Basic material glows itself
                const neonStrip = new THREE.Mesh(neonGeo, neonMat);
                neonStrip.position.y = height * Math.random();
                building.add(neonStrip);

                building.userData = { isBuilding: true, bounds: new THREE.Box3().setFromObject(building) };
                cityGroup.add(building);
                buildings.push(building);
            }
        }
    }
    scene.add(cityGroup);
}
createCity();

// --- CAR SYSTEM ---
const carGroup = new THREE.Group();
let smokeParticles = [];

function buildCar() {
    while(carGroup.children.length > 0) carGroup.remove(carGroup.children[0]);

    const color = Cars[Game.currentCar].color;
    
    // Low Poly JDM Style Car
    const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.5 });
    
    // Main Body
    const chassis = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 4.2), bodyMat);
    chassis.position.y = 0.6;
    chassis.castShadow = true;
    carGroup.add(chassis);
    
    // Cabin
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.5, 2.2), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0 }));
    cabin.position.set(0, 1.15, -0.3);
    carGroup.add(cabin);
    
    // Spoiler (Drift essential!)
    const spoiler = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.1, 0.5), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    spoiler.position.set(0, 1.0, 1.9);
    carGroup.add(spoiler);
    const spoilerLegs = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.3, 0.1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    spoilerLegs.position.set(0, 0.85, 1.9);
    carGroup.add(spoilerLegs);

    // Wheels (Cambered)
    const wGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
    wGeo.rotateZ(Math.PI/2);
    const wMat = new THREE.MeshStandardMaterial({color: 0x111111});
    
    const wheels = [
        {x: -1, z: 1.4}, {x: 1, z: 1.4}, // Rear
        {x: -1, z: -1.4}, {x: 1, z: -1.4} // Front
    ];
    
    wheels.forEach(pos => {
        const w = new THREE.Mesh(wGeo, wMat);
        w.position.set(pos.x, 0.35, pos.z);
        // Slight camber for drift look
        w.rotation.z = pos.x > 0 ? -0.1 : 0.1; 
        carGroup.add(w);
    });

    // Headlights
    const hl = new THREE.SpotLight(0xffffff, 8, 60, 0.8, 0.5, 1);
    hl.position.set(0, 0.8, 2);
    hl.target.position.set(0, 0, 10);
    carGroup.add(hl);
    carGroup.add(hl.target);
}

buildCar();
scene.add(carGroup);

// Setup Smoke System
const smokeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const smokeMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 });
const smokeGroup = new THREE.Group();
scene.add(smokeGroup);

function emitSmoke() {
    if(smokeGroup.children.length > 50) {
        smokeGroup.remove(smokeGroup.children[0]);
    }
    const p = new THREE.Mesh(smokeGeo, smokeMat);
    // Emit from rear tires
    p.position.copy(carGroup.position);
    p.position.y = 0.2;
    p.position.x += (Math.random() - 0.5) * 1.5;
    p.position.z += 1.5; // Rear
    p.scale.set(1, 1, 1);
    p.userData = { life: 1.0 };
    smokeGroup.add(p);
}

// Physics Vars
const CarPhys = {
    speed: 0,
    accel: 0,
    rotation: 0,
    vx: 0, vz: 0,
    driftFactor: 0.96 // How much velocity is retained (lower = tighter grip)
};

function updateCarStats() {
    const stats = Cars[Game.currentCar];
    CarPhys.accel = stats.accel;
    // Lower grip value in stats means MORE drift (less friction perpendicular to wheels)
    buildCar();
    updatePhoneUI(); // Refresh UI to show ownership
}

// Controls
const keys = { w: false, a: false, s: false, d: false };
window.addEventListener('keydown', (e) => { 
    if(e.key.toLowerCase() === 'r') respawnPlayer();
    if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; 
});
window.addEventListener('keyup', (e) => { 
    if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; 
});

const setupTouch = (id, key) => {
    const el = document.getElementById(id);
    if(el) {
        el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
        el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
    }
};
setupTouch('btn-gas', 'w');
setupTouch('btn-brake', 's');
setupTouch('btn-left', 'a');
setupTouch('btn-right', 'd');

// --- GAME LOGIC ---

function updatePhysics() {
    const carStats = Cars[Game.currentCar];

    // Gas & Brake
    if(keys.w) CarPhys.speed += carStats.accel;
    if(keys.s) CarPhys.speed -= carStats.accel;
    
    // Friction - Ökad för bättre kontroll (0.98 -> 0.97)
    CarPhys.speed *= 0.97;

    // Steering - Snabbare styrning för att kunna kasta bilen in i sladd
    if(Math.abs(CarPhys.speed) > 0.5) {
        const turnSpeed = 0.05 * (CarPhys.speed > 0 ? 1 : -1);
        if(keys.a) CarPhys.rotation += turnSpeed;
        if(keys.d) CarPhys.rotation -= turnSpeed;
    }

    // Velocity Vector Logic (The Drifting Part)
    // 1. Calculate ideal velocity vector based on where car is facing
    const frontVx = Math.sin(CarPhys.rotation) * CarPhys.speed;
    const frontVz = Math.cos(CarPhys.rotation) * CarPhys.speed;

    // 2. Blend current velocity towards ideal velocity based on GRIP
    // Lower grip = current velocity persists longer = drifting
    CarPhys.vx = CarPhys.vx * carStats.grip + frontVx * (1 - carStats.grip);
    CarPhys.vz = CarPhys.vz * carStats.grip + frontVz * (1 - carStats.grip);

    // Apply movement
    const nextX = carGroup.position.x + CarPhys.vx;
    const nextZ = carGroup.position.z + CarPhys.vz;

    // Drift Detection
    // Angle between facing direction and movement direction
    const moveAngle = Math.atan2(CarPhys.vx, CarPhys.vz);
    const faceAngle = CarPhys.rotation;
    let driftAngle = Math.abs(moveAngle - faceAngle);
    // Normalize angle
    while(driftAngle > Math.PI) driftAngle -= Math.PI*2;
    while(driftAngle < -Math.PI) driftAngle += Math.PI*2;
    driftAngle = Math.abs(driftAngle);

    // DRIFT SCORING LOGIC
    const minDriftAngle = 0.3; // ca 17 grader
    const minSpeed = 5; // Sänkt från 10 för att tillåta långsammare drifting
    
    if(driftAngle > minDriftAngle && Math.abs(CarPhys.speed) > minSpeed) {
        Game.isDrifting = true;
        
        // Emit smoke
        emitSmoke();
        
        // Add points
        // Points based on Angle + Speed
        const points = Math.floor(driftAngle * Math.abs(CarPhys.speed) * 0.5);
        Game.driftPoints += points;
        
        // Increase multiplier slowly
        if(Game.driftMultiplier < 10) Game.driftMultiplier += 0.01;
        
        Game.driftComboTimer = 2.0; // Seconds to keep combo alive
        
        updateDriftUI(true);
    } else {
        Game.isDrifting = false;
        if(Game.driftComboTimer > 0) {
            Game.driftComboTimer -= 0.016; // 60fps approx
        } else {
            // Bank points if combo over
            if(Game.driftPoints > 0) {
                bankPoints();
            }
        }
    }

    // Collision Check
    let collided = false;
    const carBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextX, 0.5, nextZ), new THREE.Vector3(2, 2, 4));

    for(let b of buildings) {
        if(b.position.distanceToSquared(carGroup.position) < 2500) { 
             const bBox = new THREE.Box3().setFromObject(b);
             if(carBox.intersectsBox(bBox)) {
                 collided = true;
                 
                 // Crash penalty
                 if(Game.driftPoints > 0) {
                     showNotification("CRASH! Combo Lost!");
                     Game.driftPoints = 0;
                     Game.driftMultiplier = 1.0;
                     updateDriftUI(false);
                 }

                 // Bounce
                 CarPhys.speed *= -0.5;
                 CarPhys.vx *= -0.8; 
                 CarPhys.vz *= -0.8;
                 carGroup.position.x -= CarPhys.vx * 3; 
                 carGroup.position.z -= CarPhys.vz * 3;
                 break;
             }
        }
    }

    if(!collided) {
        carGroup.position.x = nextX;
        carGroup.position.z = nextZ;
    }

    // Visuals
    carGroup.rotation.y = CarPhys.rotation;

    // Camera - Dynamic Drift Cam
    // Camera swings out opposite to rotation when drifting
    const relativeCameraOffset = new THREE.Vector3(
        Math.sin(driftAngle) * (keys.a ? 3 : (keys.d ? -3 : 0)), // Slight side offset based on turn
        6, 
        -14
    );
    const cameraOffset = relativeCameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), CarPhys.rotation);
    const targetCamPos = new THREE.Vector3(carGroup.position.x + cameraOffset.x, carGroup.position.y + cameraOffset.y, carGroup.position.z + cameraOffset.z);
    
    camera.position.lerp(targetCamPos, 0.1);
    camera.lookAt(carGroup.position.x, carGroup.position.y + 1, carGroup.position.z);

    // Update Smoke
    smokeGroup.children.forEach(p => {
        p.position.y += 0.05;
        p.material.opacity -= 0.01;
        p.scale.addScalar(0.1);
        if(p.material.opacity <= 0) smokeGroup.remove(p);
    });

    document.getElementById('speed-display').innerText = Math.floor(Math.abs(CarPhys.speed) * 10);
}

function bankPoints() {
    const total = Math.floor(Game.driftPoints * Game.driftMultiplier);
    if(total > 100) {
        showNotification(`Combo Avslutad! +$${total}`);
        Game.money += total;
        updateHUD();
    }
    Game.driftPoints = 0;
    Game.driftMultiplier = 1.0;
    updateDriftUI(false);
}

function updateDriftUI(active) {
    const el = document.getElementById('drift-panel');
    if(active) {
        el.classList.add('active');
        document.getElementById('drift-score-ui').innerText = Math.floor(Game.driftPoints);
        document.getElementById('drift-multi-ui').innerText = Game.driftMultiplier.toFixed(1);
    } else {
        el.classList.remove('active');
    }
}

// --- UI LOGIC ---

const app = {
    togglePhone: () => {
        const p = document.getElementById('phone');
        p.classList.toggle('hidden-phone');
        updatePhoneUI();
    },
};

function updatePhoneUI() {
    document.getElementById('phone-money').innerText = Game.money;
    const list = document.getElementById('car-list');
    list.innerHTML = '';
    
    for(let key in Cars) {
        const c = Cars[key];
        const owned = Game.carsOwned.includes(key);
        const current = Game.currentCar === key;
        
        let btnHtml = '';
        if(current) btnHtml = `<span class="text-green-500 text-xs font-bold">VALD</span>`;
        else if(owned) btnHtml = `<button onclick="equipCar('${key}')" class="bg-gray-700 px-3 py-1 rounded text-xs hover:bg-gray-600">VÄLJ</button>`;
        else btnHtml = `<button onclick="buyCar('${key}')" class="bg-yellow-600 text-black font-bold px-3 py-1 rounded text-xs hover:bg-yellow-500">$${c.cost}</button>`;

        list.innerHTML += `
            <div class="app-btn justify-between">
                <div>
                    <div class="font-bold text-sm ${current ? 'text-yellow-400' : 'text-white'}">${c.name}</div>
                    <div class="text-xs text-gray-500">Speed: ${c.speed} | Drift: ${(1-c.grip)*1000}</div>
                </div>
                ${btnHtml}
            </div>
        `;
    }
}

window.buyCar = (key) => {
    const c = Cars[key];
    if(Game.money >= c.cost) {
        Game.money -= c.cost;
        Game.carsOwned.push(key);
        showNotification("Köpte " + c.name);
        updatePhoneUI();
        updateHUD();
    } else {
        showNotification("Inte tillräckligt med poäng!");
    }
};

window.equipCar = (key) => {
    Game.currentCar = key;
    updateCarStats();
    showNotification("Kör nu: " + Cars[key].name);
};

window.respawnPlayer = () => {
    CarPhys.speed = 0;
    CarPhys.vx = 0;
    CarPhys.vz = 0;
    carGroup.position.set(0, 0.5, 0); 
    carGroup.rotation.set(0,0,0);
    showNotification("Respawnad vid garaget.");
};

function updateHUD() {
    document.getElementById('money-display').innerText = Game.money;
}

function showNotification(text) {
    const n = document.getElementById('notification');
    n.innerText = text;
    n.style.opacity = 1;
    setTimeout(() => n.style.opacity = 0, 3000);
}

// Loop
function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Init
updateCarStats();
updatePhoneUI();
setTimeout(() => app.togglePhone(), 500);

</script>
</body>
</html>
